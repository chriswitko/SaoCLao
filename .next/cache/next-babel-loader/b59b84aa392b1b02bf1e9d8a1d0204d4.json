{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _Promise from \"@babel/runtime-corejs2/core-js/promise\";\nimport _parseInt from \"@babel/runtime-corejs2/core-js/parse-int\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport constate from 'constate';\nimport React, { useRef, useCallback, useState, useMemo } from 'react';\nimport { useImmer } from 'use-immer';\nimport { options, musicPlayer } from '../constants/musicPlayer.constant';\n\nconst isCurrentTrack = (trackId, currentTrack) => trackId === currentTrack.id;\n\nconst useMusicPlayer = params => {\n  const {\n    0: currentTrack,\n    1: setCurrentTrack\n  } = useState({\n    id: 11,\n    playing: false\n  });\n  const onAudioListsChange = React.useCallback((currentPlayId, audioLists, audioInfo) => {\n    setMusicPlayerOptions(preOptions => _objectSpread({}, preOptions, {\n      audioLists\n    }));\n  }, []);\n  const onAudioPause = React.useCallback(audioInfo => {\n    setCurrentTrackPause(_parseInt(audioInfo.lyric));\n  }, []);\n  const onAudioPlay = React.useCallback(audioInfo => {\n    setCurrentTrackPlaying(_parseInt(audioInfo.lyric));\n  }, []);\n  const getAudioInstance = React.useCallback(audioInstance => {\n    musicPlayer.setInstance(audioInstance);\n  }, []);\n  const {\n    0: musicPlayerOptions,\n    1: setMusicPlayerOptions\n  } = useState(_objectSpread({}, options, {\n    onAudioListsChange,\n    getAudioInstance,\n    onAudioPause,\n    onAudioPlay\n  }));\n  const playTrack = React.useCallback(track => {\n    if (!isCurrentTrack(track.id, currentTrack)) {\n      console.log('play diff song', track.id, currentTrack);\n      addTrackToAudioList({\n        name: track.name,\n        singer: track.artist,\n        cover: track.artwork_url,\n        id: track.id,\n        lyric: `${track.id}`,\n        musicSrc: () => _Promise.resolve(`https://api.soundcloud.com/tracks/${track.id}/stream?client_id=${process.env.SOUNDCLOUD_CLIENT_ID}`)\n      });\n    }\n\n    musicPlayer.getInstance().play();\n  }, [currentTrack]);\n  const pauseTrack = React.useCallback(track => {\n    musicPlayer.getInstance().pause();\n  }, []);\n  const addTrackToAudioList = React.useCallback(track => {\n    setMusicPlayerOptions(preOptions => _objectSpread({}, preOptions, {\n      // if use global state: musicPlayerOptions instead of local state: preOptions,\n      // it will cache the initial musicPlayerOptions because of useCallbackOnce\n      // Maybe this doesn't apply for dispatch in useReducer, I don't know\n      audioLists: [track, ...preOptions.audioLists]\n    }));\n  }, []);\n  const setCurrentTrackPlaying = React.useCallback(trackId => {\n    setCurrentTrack(preTrack => {\n      const currentTrack = {\n        id: trackId,\n        playing: true\n      };\n      return currentTrack;\n    });\n  }, []);\n  const setCurrentTrackPause = React.useCallback(trackId => {\n    setCurrentTrack(preTrack => {\n      const currentTrack = {\n        id: trackId,\n        playing: false\n      };\n      return currentTrack;\n    });\n  }, []);\n  const isCurrentTrackPlaying = React.useCallback(trackId => currentTrack.id === trackId && currentTrack.playing, [currentTrack]);\n  return {\n    currentTrack,\n    isCurrentTrackPlaying,\n    musicPlayerOptions,\n    addTrackToAudioList,\n    playTrack,\n    pauseTrack\n  };\n};\n\nexport const [MusicPlayerProvider, useCurrentTrack, useIsCurrentTrackPlaying, useMusicPlayerOptions, useAddTrackToAudioList, usePlayTrack, usePauseTrack] = constate(useMusicPlayer, value => value.currentTrack, value => value.isCurrentTrackPlaying, value => value.musicPlayerOptions, value => value.addTrackToAudioList, value => value.playTrack, value => value.pauseTrack);","map":null,"metadata":{},"sourceType":"module"}